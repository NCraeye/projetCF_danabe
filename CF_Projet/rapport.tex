\documentclass[a4paper]{book}
\usepackage{fullpage}

\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage[francais]{babel}

\usepackage{latexsym}
\usepackage{fancyhdr}
\usepackage{makeidx}
\usepackage{graphics}
\usepackage{graphicx}
\usepackage{float} %
\usepackage{caption} %
\usepackage{longtable}
\usepackage{moreverb}
\usepackage{listings}

\newcommand{\altarica}{{\sc AltaRica}}

\begin{document}

\title{Master 1, Conceptions Formelles\\
Projet du module \altarica\\
Synthèse (assistée) d'un contrôleur du niveau d'une cuve}

\date{}

\author{Craeye Nathalie \and Faltrept Bérénice \and Lejeune David}

\maketitle

\chapter{Le sujet}
\input{tank}

\chapter{Le rapport}

Pour les deux questions qui suivent, nous avons analysé essentiellement les fichiers GNUmakefile à la racine du projet, system.alt, parameters.alt, tank.alt, test.alt, et CtrlVV.alt.
En effet nous avons remarqués dans le fichier GNUmakefile, qu'à l'utilisation de la commande "make" on génère toutes les configurations possibles du système sur lequel nous travaillons : 
une première boucle assure la génération des fichiers pour tous les contrôleurs ( Ctrl et CtrlVV). Pour chacun d'entre eux, une boucle va produire des fichiers associés aux nombres de pannes.

\section{Rôle de la constante {\tt nbFailures} (2 points)}

$nbFailures$ est la constante qui récupère le nombre de pannes prédéfini au lancement d'une configuration du système. En effet, elle est initialisée en prenant la valeur de la variable $nbPannes$ dans le système en cours. \\
La contrainte, et assertion, du composant {\tt System} $nbFailures >= (V[0].fail + V[1].fail + V[2].fail)$ permet d'assurer que le modèle lancé par l'utilisateur a une configuration cohérente, c'est-à-dire que le nombre de valves en panne dans le modèle en cours sera compris entre 0 (meilleur cas : il n'y aurait aucune valve en panne) et 3 (pire cas : les trois valves, i.e toutes, existantes du système sont en panne). \\

\section{Rôle des composants {\tt ValveVirtual} et {\tt CtrlVV} (4 points)}

$ValveVirtual$ est le composant permettant de simuler une valve parfaite, autrement dit sans panne. En l'intégrant au modèle, via CtrlVV, on peut alors confirmer la cohérence du modèle indépendemment de la gestion des pannes. \\
$CtrlVV$ est un composant pouvant prendre la place du contrôleur. Ce qui l'en distingue est sa capacité à gérer en parallèle du système, une simulation du système mais dans laquelle aucune panne n'est possible. Lorsqu'il agit sur une des valve du système réel, $CtrlVV$ reproduit la même action sur la Valve correspondante du simulateur. \\
Si les conséquences dans la cuve réelle sont différentes de celles dans la cuve simulée, alors il détecte une défaillance de cette valve.

\section{Résultats avec le contrôleur initial {\tt Ctrl}}

\subsection{Calcul d'un contrôleur}

\subsubsection{Avec 0 défaillance (1 point)}
\lstinputlisting{Res/System0FCtrl.res}
\lstinputlisting{Res/System0FCtrl0F1I.res}
\lstinputlisting{Res/System0FCtrl0F2I.res}
\lstinputlisting{Res/System0FCtrl0F3I.res}
\lstinputlisting{Res/System0FCtrl0F4I.res}
\paragraph{Interprétation des résultats}

On observe que sur les différentes itérations : excepté la première, elles sont toutes identiques. De plus, notre système n'a aucun deadlock et les situations redoutées n'existent plus après cette première tentative. Donc les modifications appliquées à partir de l'itération 1 sont concluantes et permettent d'obtenir un système que l'on peut supposer fiable.

\begin{itemize}
	\item Oui. À partir de l'itération 1, il n'y a plus de situation critique et nous n'avions aucun état puit. Or, dans cette situation, CtrlCanControl parvient à contrôler 27 transitions.
	\item Out2 étant la sortie utilisée dans le plus de situations (ou sommets) alors que les situations critiques sont nulles. Il est donc optimal.

\end{itemize}

\subsubsection{Avec 1 défaillance (1 point)}
\lstinputlisting{Res/System1FCtrl.res}
\lstinputlisting{Res/System1FCtrl1F1I.res}
\lstinputlisting{Res/System1FCtrl1F2I.res}
\lstinputlisting{Res/System1FCtrl1F3I.res}
\lstinputlisting{Res/System1FCtrl1F4I.res}
\paragraph{Interprétation des résultats}

Nous voyons que comparé à la version 0 défaillance, l'itération initiale a beaucoup plus de situations redoutées possibles, ce qui est normal pour une situation avec une valve défaillante. \\
À la première itération, nous remarquons des états puits produits, et que les sommets pour lesquels le niveau d'eau est critique sont tous des deadlocks puisque SR est équivalent à deadlock. \\ 
Or, en utilisant Altarica studio on s'aperçoit que la trace des deadlock ne nous mènent qu'à 4 sommets. En affichant le graphe avec la commande $dot(any\_s, tr\_deadlock)$, on découvre que ces 4 cas sont lorsque le niveau de l'eau dans la cuve est débordant.

\begin{figure}[H]
  \centering
  \includegraphics[width=14cm]{img/CtrlF1I1.png}
  %\caption{}
\end{figure}

\begin{itemize}
	\item En ayant une valve défaillante, on peut contrôler toutes les situations excepté les débordements de cuves, qui peuvent arriver quelle que soit la valve abîmée. Dans ce cas, on doit trouver une solution spécifique à ce problème : par exemple, garder une ouverture en haut de la cuve qui entrainerait une déperdition de l'eau le temps que l'on répare la valve. Donc non.
	\item Comme nous le voyons sur l'image : à aucun moment le débit aval n'intervient sur les trajets partant du sommet initial et arrivant à une situation bloquée (deadlock). Donc non.

\end{itemize}

\subsubsection{Avec 2 défaillances (1 point)}
\lstinputlisting{Res/System2FCtrl.res}
\lstinputlisting{Res/System2FCtrl2F1I.res}
\lstinputlisting{Res/System2FCtrl2F2I.res}
\lstinputlisting{Res/System2FCtrl2F3I.res}
\lstinputlisting{Res/System2FCtrl2F4I.res}
\paragraph{Interprétation des résultats}

Nous remarquons qu'à l'initialisation, il n'y a pas de deadlock mais par contre, le nombre de situation redoutées accessibles sont nombreuses.
Cependant, à la première occurence, on obtient 2 deadlock traçables. Via altarica-studio, nous avons constaté que le problème survient lorsque le niveau de l'eau dans la cuve est de 2 et que les valves cassées font augmenter son niveau.

\begin{figure}[H]
  \centering
  \includegraphics[width=14cm]{img/CtrlF2I1.png}
  %\caption{}
\end{figure}

\subsubsection{Avec 3 défaillances (1 point)}
\lstinputlisting{Res/System3FCtrl.res}
\lstinputlisting{Res/System3FCtrl3F1I.res}
\lstinputlisting{Res/System3FCtrl3F2I.res}
\lstinputlisting{Res/System3FCtrl3F3I.res}
\lstinputlisting{Res/System3FCtrl3F4I.res}
\paragraph{Interprétation des résultats}



\subsection{Calcul des contrôleurs optimisés (2 points)}

\section{Résultats avec le contrôleur initial {\tt CtrlVV}}

\subsection{Calcul d'un contrôleur}

\subsubsection{Avec 0 défaillance (1 point)}
\lstinputlisting{Res/System0FCtrlVV.res}
\lstinputlisting{Res/System0FCtrlVV0F1I.res}
\lstinputlisting{Res/System0FCtrlVV0F2I.res}
\lstinputlisting{Res/System0FCtrlVV0F3I.res}
\lstinputlisting{Res/System0FCtrlVV0F4I.res}
\paragraph{Interprétation des résultats}

Comme attendu, lors des itérations nous n'avons aucune situation redoutée puisque nous traitons un cas sans défaillance. \\ 
On peut donc supposer que l'on est sur un système parfait pour ce nombre de défaillance. Nous remarquons aussi que nous avons les mêmes valeurs que lors de l'utilisation du contrôleur classique avec aucune défaillance, seul le nombre de transition varie.

\begin{itemize}
	\item Oui, effectivement nous voyons que nous sommes sans situations redoutées mais que CtrlCanControl est de 8.
	
	\item Ce cas est similaire au premier cas étudié : Out2 est la sortie utilisée dans le plus de situations (ou sommets) alors que les situations critiques sont nulles. Il est donc optimal.
 
\end{itemize}

\subsubsection{Avec 1 défaillance (1 point)}
\lstinputlisting{Res/System1FCtrlVV.res}
\lstinputlisting{Res/System1FCtrlVV1F1I.res}
\lstinputlisting{Res/System1FCtrlVV1F2I.res}
\lstinputlisting{Res/System1FCtrlVV1F3I.res}
\lstinputlisting{Res/System1FCtrlVV1F4I.res}
\paragraph{Interprétation des résultats}


\subsubsection{Avec 2 défaillances (1 point)}
\lstinputlisting{Res/System2FCtrlVV.res}
\lstinputlisting{Res/System2FCtrlVV2F1I.res}
\lstinputlisting{Res/System2FCtrlVV2F2I.res}
\lstinputlisting{Res/System2FCtrlVV2F3I.res}
\lstinputlisting{Res/System2FCtrlVV2F4I.res}
\paragraph{Interprétation des résultats}


\subsubsection{Avec 3 défaillances (1 point)}
\lstinputlisting{Res/System3FCtrlVV.res}
\lstinputlisting{Res/System3FCtrlVV3F1I.res}
\lstinputlisting{Res/System3FCtrlVV3F2I.res}
\lstinputlisting{Res/System3FCtrlVV3F3I.res}
\lstinputlisting{Res/System3FCtrlVV3F4I.res}
\paragraph{Interprétation des résultats}

\subsection{Calcul des contrôleurs optimisés (2 points)}

\section{Conclusion (2 points)}

Finalement, nous ne sommes pas parvenus à aboutir ce projet. Durant l'analyse des différents systèmes nous nous sommes plusieurs fois demandé quelle est la définition d'une itération sans parvenir à une définition précise. Nous avons donc travaillé sur des suppositions.\\
De plus, nous n'avons pas compris si nous devions modifier manuellement les contrôleurs générés dans le dossier $Controleurs$ lorsqu'ils ont des deadlocks.\\
En revanche notre attention s'est focalisée sur le fonctionnement du projet. Nous avons ainsi assimilé la signification des opérateurs et le rôle des composants des systèmes. \\

En nous basant sur nos connaissances d'altarica-studio, nous avons pu exposer des éléments de réponses malgré une exploitation incomplète de ces résultats. \\

\end{document}
